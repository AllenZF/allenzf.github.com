
每天都在叫嚣自己会什么技术，什么框架，可否意识到你每天都在被这些新名词、新技术所迷惑，.NET、XML等等技术固然诱人，可是如果自己的基础不扎实，就像是在云里雾里行走一样，只能看到眼前，不能看到更远的地方。这些新鲜的技术掩盖了许多底层的原理，要想真正的学习技术还是走下云端，扎扎实实的把基础知识学好，有了这些基础，要掌握那些新技术也就很容易了。
要编写出优秀的代码同样要扎实的基础，如果排序和查找算法学的不好，怎么对程序的性能进行优化？废话不多说，本文要介绍的这些排序算法就是基础中的基础，程序员必知！
![]({{site.url}}/_picture/search_ranking/ranking.png)
1、直接插入排序

（1）基本思想：在要排序的一组数中，假设前面(n-1) [n>=2] 个数已经是排

好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数

也是排好顺序的。如此反复循环，直到全部排好顺序。

（2）实例
![]({{site.url}}/_picture/search_ranking/插入.png)
2、希尔排序（也称最小增量排序）



（1）基本思想：算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。

（2）实例：
![]({{site.url}}/_picture/search_ranking/希尔.png)
3、简单选择排序



（1）基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；

然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。

（2）实例：
![]({{site.url}}/_picture/search_ranking/选择.png)
4、堆排序



（1）基本思想：堆排序是一种树形选择排序，是对直接选择排序的有效改进。

堆的定义如下：具有n个元素的序列（h1,h2,...,hn),当且仅当满足（hi>=h2i,hi>=2i+1）或（hi<=h2i,hi<=2i+1）(i=1,2,...,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。

（2）实例：

初始序列：46,79,56,38,40,84

建堆：
![]({{site.url}}/_picture/search_ranking/建堆.png)
交换，从堆中踢出最大数
![]({{site.url}}/_picture/search_ranking/堆_交换.png)
剩余结点再建堆，再交换踢出最大数
![]({{site.url}}/_picture/search_ranking/堆_wan.png)
依次类推：最后堆中剩余的最后两个结点交换，踢出一个，排序完成。

5、冒泡排序



（1）基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。

（2）实例：
![]({{site.url}}/_picture/search_ranking/冒泡.png)

6、快速排序

（1）基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。

（2）实例：
![]({{site.url}}/_picture/search_ranking/快排.png)
上图中将待排序列分成两部分,一部分比基准元素小,一部分大于基准元素,然后对这两部分重复上图的求解过程。

（这只是快速排序的一种实现方式，个人认为比较容易理解）



7、归并排序



（1）基本排序：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。

（2）实例：
![]({{site.url}}/_picture/search_ranking/归并.png)
8、基数排序



（1）基本思想：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。

（2）实例：
![]({{site.url}}/_picture/search_ranking/基数.png)
稳定性说明：排序前，2（或者更多）个相等的数在序列的前后位置顺序和排序后它们在序列中的前后位置顺序一样。



实例：

待排序数列：5,4,8,6,1,8,7,9

排序结果：1,4,5,6,7,8,8,9

稳定：1,4,5,6,7,8,8,9

不稳定：1,4,5,6,7,8,8,9



说明：对比红色的8和紫色的8，看他们排序前后的位置。排序前，红8在紫8前面，如果排序后红8仍然在紫8前面，则排序算法稳定，否则不稳定。 



现在我们分析一下8种排序算法的稳定性。

（请网友结合前面的排序基本思想来理解排序的稳定性（8种排序的基本思想已经在前面说过，这里不再赘述）不然可能有些模糊）

（1）直接插入排序：一般插入排序，比较是从有序序列的最后一个元素开始，如果比它大则直接插入在其后面，否则一直往前比。如果找到一个和插入元素相等的，那么就插入到这个相等元素的后面。插入排序是稳定的。

（2）希尔排序：希尔排序是按照不同步长对元素进行插入排序，一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，稳定性就会被破坏，所以希尔排序不稳定。

（3）简单选择排序：在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。光说可能有点模糊，来看个小实例：858410，第一遍扫描，第1个元素8会和4交换，那么原序列中2个8的相对前后顺序和原序列不一致了，所以选择排序不稳定。

（4）堆排序：堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n/2-1, n/2-2, ...这些父节点选择元素时，有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没有交换，所以堆排序并不稳定。

（5）冒泡排序：由前面的内容可知，冒泡排序是相邻的两个元素比较，交换也发生在这两个元素之间，如果两个元素相等，不用交换。所以冒泡排序稳定。

（6）快速排序：在中枢元素和序列中一个元素交换的时候，很有可能把前面的元素的稳定性打乱。还是看一个小实例：6 4 4 5 4 7 8  9，第一趟排序，中枢元素6和第三个4交换就会把元素4的原序列破坏，所以快速排序不稳定。

（7）归并排序：在分解的子列中，有1个或2个元素时，1个元素不会交换，2个元素如果大小相等也不会交换。在序列合并的过程中，如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，所以，归并排序也是稳定的。

（8）基数排序：是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。

8种排序的分类，稳定性，时间复杂度和空间复杂度总结：
![]({{site.url}}/_picture/search_ranking/排序总结.png)
三种查找算法:顺序查找，二分法查找（折半查找），分块查找，散列表（以后谈）
![]({{site.url}}/_picture/search_ranking/查找.png)
一、顺序查找的基本思想：

从表的一端开始，顺序扫描表，依次将扫描到的结点关键字和给定值（假定为a）相比较，若当前结点关键字与a相等，则查找成功；若扫描结束后，仍未找到关键字等于a的结点，则查找失败。

说白了就是，从头到尾，一个一个地比，找着相同的就成功，找不到就失败。很明显的缺点就是查找效率低。

适用于线性表的顺序存储结构和链式存储结构。
![]({{site.url}}/_picture/search_ranking/查找_1.png)
计算平均查找长度。

例如上表，查找1，需要1次，查找2需要2次，依次往下推，可知查找16需要16次，

可以看出，我们只要将这些查找次数求和（我们初中学的，上底加下底乘以高除以2），然后除以结点数，即为平均查找长度。

设n=节点数

平均查找长度=（n+1）/2


二、二分法查找（折半查找）的基本思想：



前提：

（1）确定该区间的中点位置：mid=（low+high）/2

min代表区间中间的结点的位置，low代表区间最左结点位置，high代表区间最右结点位置

（2）将待查a值与结点mid的关键字（下面用R[mid].key）比较，若相等，则查找成功，否则确定新的查找区间：

如果R[mid].key>a，则由表的有序性可知，R[mid].key右侧的值都大于a，所以等于a的关键字如果存在，必然在R[mid].key左边的表中。这时high=mid-1

如果R[mid].key<a,则等于a的关键字如果存在，必然在R[mid].key右边的表中。这时low=mid

如果R[mid].key=a，则查找成功。

（3）下一次查找针对新的查找区间，重复步骤（1）和（2）

（4）在查找过程中，low逐步增加，high逐步减少，如果high<low，则查找失败。
![]({{site.url}}/_picture/search_ranking/二分查找.png)
平均查找长度=Log2(n+1)-1

注：虽然二分法查找的效率高，但是要将表按关键字排序。而排序本身是一种很费时的运算，所以二分法比较适用于顺序存储结构。为保持表的有序性，在顺序结构中插入和删除都必须移动大量的结点。因此，二分查找特别适用于那种一经建立就很少改动而又经常需要查找的线性表。


三、分块查找的基本思想：



二分查找表使分块有序的线性表和索引表（抽取各块中的最大关键字及其起始位置构成索引表

）组成，由于表是分块有序的，所以索引表是一个递增有序表，因此采用顺序或二分查找索引表，以确定待查结点在哪一块，由于块内无序，只能用顺序查找。
![]({{site.url}}/_picture/search_ranking/分块.png)
设表共n个结点，分b块，s=n/b

(分块查找索引表)平均查找长度=Log2（n/s+1）+s/2

(顺序查找索引表)平均查找长度=(S2+2S+n)/(2S)

注：分块查找的优点是在表中插入或删除一个记录时，只要找到该记录所属块，就在该块中进行插入或删除运算（因块内无序，所以不需要大量移动记录）。它主要代价是增加一个辅助数组的存储控件和将初始表分块排序的运算。

它的性能介于顺序查找和二分查找之间。



四、最近比较忙，后续找个时间还会谈谈散列表（哈希表）技术，希望大家关注！

散列表查找技术不同于顺序查找、二分查找、分块查找。它不以关键字的比较为基本操作，采用直接寻址技术。在理想情况下，无须任何比较就可以找到待查关键字，查找的期望时间为O(1)。
